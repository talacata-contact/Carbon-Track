/*
Copyright ¬© 2025 TALACATA.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import api from '@/api/api';
import { getdb } from '@/db/connectdb';

////////////////////////////////////////////////////////////////////////////////////
// SUGGESTIONS
////////////////////////////////////////////////////////////////////////////////////

// GET - R√©cup√©ration des suggestions d'une cat√©gorie
export const getSuggestionsByCategorie = async (categorie, events_done) => {
    // console.log("üéØ‚Äã R√©cup√©ration des suggestions d'une cat√©gorie");
    try {
        // r√©cup√©ration de la base de donn√©es
        const db = await getdb();

        // r√©cup√©ration des suggestions de la cat√©gorie
        const sql = 'SELECT * FROM suggestions WHERE categorie = ?';
        const suggestions = await db.getAllAsync(sql, [categorie]);

        // v√©rification de la r√©cup√©ration
        // console.log("üëâ‚Äã Suggestions pour la cat√©gorie ", categorie, ' : ', suggestions);

        // filtrage des suggestions en fonction des param√®tres des actions
        let suggestions_filtered = await filterSuggestionsByEventsDone(categorie, suggestions, events_done);

        // mise en forme des JSON
        suggestions_filtered = suggestions_filtered.map(s => ({
            ...s,
            contexte: typeof s.contexte === 'string' ? JSON.parse(s.contexte) : s.contexte,
            sources: typeof s.sources === 'string' ? JSON.parse(s.sources) : s.sources,
        }));

        // console.log("‚úÖ‚Äã R√©cup√©ration des suggestions de la cat√©gorie r√©ussie !");
        return { status: true, message: "R√©cup√©ration des suggestions de la cat√©gorie r√©ussie !", suggestions: suggestions_filtered };

    } catch (error) {
        console.log("‚ùå‚Äã Erreur lors de la r√©cup√©ration des suggestions de la cat√©gorie :", error.message);
        return { status: false, message: error.message };
    }
}

// GET - R√©cup√©ration des suggestions depuis l'API
export const getSuggestionsFromApi = async () => {
    console.log("üåê Appel √† l'API pour r√©cup√©rer les suggestions...");
    try {
        // appel √† l'API
        const response = await api.get('/suggestions');

        // v√©rification de la r√©ponse
        // console.log("üëâ‚Äã R√©ponse de l'API :", response.data);

        console.log("‚úÖ‚Äã Appel √† l'API pour r√©cup√©rer les suggestions r√©ussi !");
        return response.data.suggestions;

    } catch (error) {
        console.log("‚ùå‚Äã Erreur lors de l'appel √† l'API pour r√©cup√©rer les suggestions :", error.message);
        throw error;
    }
}

// DELETE - Suppression d'une suggestion
export const deleteSuggestion = async (id) => {
    console.log("üéØ‚Äã‚Äã Suppression d'une suggestion");
    try {
        // r√©cup√©ration de la base de donn√©es
        const db = await getdb();

        // v√©rification avant suppression
        // const sqlSelect = 'SELECT * FROM suggestions WHERE id = ?';
        // const suggestion = await db.getFirstAsync(sqlSelect, [id]);
        // console.log("üëâ‚Äã Suggestion √† supprimer :", suggestion);

        // suppression de la suggestion
        const sqlDelete = 'DELETE FROM suggestions WHERE id = ?';
        await db.runAsync(sqlDelete, [id]);

        // v√©rification apr√®s suppression
        // const sqlSelectAfter = 'SELECT * FROM suggestions WHERE id = ?';
        // const suggestionAfter = await db.getFirstAsync(sqlSelectAfter, [id]);
        // console.log("üëâ‚Äã Suggestion apr√®s suppression :", suggestionAfter);

        console.log("‚úÖ‚Äã‚Äã Suppression de la suggestion r√©ussie !");
        return { status: true, message: "Suppression de la suggestion r√©ussie !" };

    } catch (error) {
        console.log("‚ùå‚Äã Erreur lors de la suppression de la suggestion :", error.message);
        return { status: false, message: error.message };
    }
}

// SYNC - Synchronisation des suggestions
export const syncSuggestions = async () => {
    console.log("üéØ‚Äã‚Äã Synchronisation des suggestions...");
    try {
        // r√©cup√©ration des suggestions depuis l'API
        const suggestions = await getSuggestionsFromApi();

        // r√©cup√©ration de la base de donn√©es
        const db = await getdb();

        // insertion (ou mise √† jour) des suggestions
        for (const suggestion of suggestions) {
            const sqlInsert = 'INSERT OR REPLACE INTO suggestions (id, categorie, contexte, suggestion, explication, sources) VALUES (?, ?, ?, ?, ?, ?)';
            await db.runAsync(sqlInsert, [suggestion.id, suggestion.categorie, JSON.stringify(suggestion.contexte), suggestion.suggestion, suggestion.explication, JSON.stringify(suggestion.sources)]);
        }

        // suppression des suggestions non pr√©sentes dans l'API
        const placeholders = suggestions.map(() => '?').join(',');
        const sqlDelete = `DELETE FROM suggestions WHERE id NOT IN (${placeholders})`;
        const ids = suggestions.map(s => s.id);
        await db.runAsync(sqlDelete, ids);

        // v√©rification de la synchronisation
        // const sqlSelect = 'SELECT * FROM suggestions';
        // const suggestions_synced = await db.getAllAsync(sqlSelect);
        // console.log("üëâ‚Äã Suggestions synchronis√©es :", suggestions_synced);

        console.log("‚úÖ‚Äã Synchronisation des suggestions r√©ussie !");
        return { status: true, message: "Synchronisation des suggestions r√©ussie !" };

    } catch (error) {
        console.log("‚ùå‚Äã Erreur lors de la synchronisation des suggestions :", error.message);
        return { status: false, message: error.message };
    }
}

// FONCTION UTILITAIRE - Filtrage des suggestions en fonction des param√®tres d'une liste d'√©venements
const filterSuggestionsByEventsDone = async (categorie, suggestions_of_categorie, events_done) => {
    // console.log("üéØ‚Äã Filtrage des suggestions en fonction des param√®tres...");
    try {
        let suggestions_filtered = [];

        if (categorie === 'transport') {
            suggestions_filtered = suggestions_of_categorie.filter(suggestion => {
                const contexte = JSON.parse(suggestion.contexte);

                return events_done.some(event => {
                    // v√©rification de la cat√©gorie de l'action
                    if (event.action_categorie !== 'transport') return false;

                    // r√©cup√©ration des param√®tres de l'action
                    const params = event.params;
                    if (!params) return false;

                    // v√©rification des categorie_ids
                    if (contexte.categorie_ids && contexte.categorie_ids.length > 0 &&
                        !contexte.categorie_ids.includes(params.categorie_id)) {
                        return false;
                    }

                    // v√©rification de la distance sup√©rieure
                    if (contexte.distance_km !== undefined && contexte.critere === 'sup√©rieur' &&
                        !(params.distance_km > contexte.distance_km)) {
                        return false;
                    }

                    // v√©rification de la distance inf√©rieure
                    if (contexte.distance_km !== undefined && contexte.critere === 'inf√©rieur' &&
                        !(params.distance_km < contexte.distance_km)) {
                        return false;
                    }

                    // v√©rification de la consommation sup√©rieure
                    if (contexte.conso_km !== undefined && contexte.critere === 'sup√©rieur' &&
                        !(params.conso_km > contexte.conso_km)) {
                        return false;
                    }

                    // v√©rification de la consommation inf√©rieure
                    if (contexte.conso_km !== undefined && contexte.critere === 'inf√©rieur' &&
                        !(params.conso_km < contexte.conso_km)) {
                        return false;
                    }

                    return true;
                });
            });
        }

        else if (categorie === 'logement') {
            suggestions_filtered = suggestions_of_categorie.filter(suggestion => {
                const contexte = JSON.parse(suggestion.contexte);

                return events_done.some(event => {
                    // v√©rification de la cat√©gorie de l'action
                    if (event.action_categorie !== 'logement') return false;

                    // r√©cup√©ration des param√®tres de l'action
                    const params = event.params;
                    if (!params) return false;

                    // v√©rification du chauffage_id
                    if (contexte.chauffage_id !== undefined &&
                        contexte.chauffage_id !== params.chauffage_id) {
                        return false;
                    }

                    // v√©rification de la superficie
                    if (contexte.superficie_m2 !== undefined) {
                        if (contexte.critere === 'sup√©rieur' &&
                            !(params.superficie_m2 > contexte.superficie_m2)) {
                            return false;
                        }
                        if (contexte.critere === 'inf√©rieur' &&
                            !(params.superficie_m2 < contexte.superficie_m2)) {
                            return false;
                        }
                    }

                    // v√©rification de la temp√©rature de chauffage
                    if (contexte.temp_chauffage !== undefined) {
                        if (contexte.critere === 'sup√©rieur' &&
                            !(params.temp_chauffage > contexte.temp_chauffage)) {
                            return false;
                        }
                        if (contexte.critere === 'inf√©rieur' &&
                            !(params.temp_chauffage < contexte.temp_chauffage)) {
                            return false;
                        }
                    }

                    return true;
                });
            });
        }

        else if (categorie === 'aliment') {
            suggestions_filtered = suggestions_of_categorie.filter(suggestion => {
                const contexte = JSON.parse(suggestion.contexte);
                const contexte_tags = contexte.tags;

                return events_done.some(event => {
                    // v√©rification de la cat√©gorie de l'action
                    if (event.action_categorie !== 'aliment') return false;

                    // r√©cup√©ration des param√®tres de l'action
                    const params = event.params;
                    if (!params) return false;
                    const aliment_tags = JSON.parse(params.tags);
                    if (!Array.isArray(aliment_tags)) return false;

                    // v√©rification des tags
                    return contexte_tags.some(tag => aliment_tags.includes(tag));
                });
            });
        }

        // console.log("üëâ‚Äã Suggestions filtr√©es :", suggestions_filtered);
        // console.log("‚úÖ‚Äã Filtrage des suggestions en fonction des param√®tres r√©ussie !");
        return suggestions_filtered;

    } catch (error) {
        console.log("‚ùå‚Äã Erreur lors du filtrage des suggestions en fonction des param√®tres :", error.message);
        throw error;
    }
};